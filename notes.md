### Commands

| command                     | description                          | example |
| --------------------------- | ------------------------------------ | ------- |
| dbt run                     | runs the entire model -- models only |         |
| dbt run select {model name} | runs a specific model; no sql needed |         |
| dbt build                   | models + tests + seeds + snapshots   |         |


### Development

- https://github.com/snowcertmalston4-boop/DBT_DEMO
- https://docs.getdbt.com/docs/install-dbt-extension
- power user for dbt
  - https://www.youtube.com/watch?v=s-XxqNE4T1s
- https://github.com/sharetheknowledge/DBT_DEMO/blob/main/models/stg_bike.sql

### Project File

{{}} -- jinja

{%%} -- logic/macros (functions)

` {{ ref('my_first_dbt_model') }}` -- references another model

`{{ config(materialized='table') }} -- placed in model sql file, materializes .sql as table/view`

dbt will always prioritize what is in the model itself, rather than global

```
select 
* 
from {{ source('demo', 'bike') }}

limit 10
```

a

```
select 
* 
from {{ ref('my_second_dbt_model') }}

limit 10
```

- the target folder in dbt shows the raw .sql that is generated by dbt after processing jinja templates
- "compiled/ shows rendered SQL, run/ shows executed SQL" because the
  compiled/ folder contains the SQL code generated after Jinja templates
  are processed, while the run/ folder contains the SQL that has been
  executed against the database, helping you understand both the
  transformation process and the results. This distinction is vital for
  debugging and validating your dbt models.

### Macros

- go in macro directory
- ![](assets\20250825_220434_image.png)
- calling the macro:

### Orchestration

- CREATE TASK (...) WAREHOUSE=(...) SCHEDULE='USING CRON 0 0 * * * UTC'
- CREATE TASK (...) WAREHOUSE = (...) [AFTER (TASK_NAME)] AS (...)
